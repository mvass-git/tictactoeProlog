Вимоги та налаштування
Необхідне програмне забезпечення
Python 3.6+ – рекомендовано останню стабільну версію.

Flask – веб-фреймворк для Python.

Flask-CORS – розширення для роботи з CORS.

pyswip – бібліотека для інтеграції SWI-Prolog з Python.

SWI-Prolog – Prolog-середовище (завантажте з офіційного сайту SWI-Prolog).

Встановлення залежностей
Встановіть Python (якщо ще не встановлено).

Створіть віртуальне середовище (необов’язково, але рекомендовано):

python -m venv venv
source venv/bin/activate  # Linux/MacOS
venv\Scripts\activate     # Windows
Встановіть необхідні пакети:

pip install Flask Flask-CORS pyswip
Завантажте та встановіть SWI-Prolog.

Запуск проєкту
Переконайтесь, що файли app.py і game_logic.pl знаходяться в одній папці, а файл index.html знаходиться у підпапці static.

Запустіть Flask-сервер:
python app.py
Відкрийте веб-браузер і перейдіть за адресою http://127.0.0.1:5000.
Налаштуйте параметри гри (розміри поля, режим гри, затримку бота, рівень складності) та натисніть кнопку Start Game.

Цей проєкт реалізує гру «Хрестики-Нулики» із можливістю гри людина проти людини, людина проти бота та бот проти бота. Основна логіка гри (перевірка переможця, оцінка позицій, критична загроза, вибір ходу за різними рівнями складності) реалізована мовою Prolog, а веб-інтерфейс побудовано за допомогою Flask (Python) та простого HTML/JavaScript.

Для зв’язку між компонентами використовується бібліотека pyswip, що дозволяє консультувати Prolog-файл з Python. Також проводиться перетворення типів даних (наприклад, список списків з Python у список списків Prolog, а також форматування результатів ходу бота) для забезпечення коректного обміну даними.

Використані алгоритми та підходи
1. Логіка гри
Перевірка переможця.
Використовується предикат check_winner/4, який проходить по всіх комірках і перевіряє, чи існує послідовність з N елементів, що належать одному гравцю.
Оригінальний прийом: Використання предиката line_in_direction/8 із генерацією позицій через between/3 та findall/3.

Збір порожніх клітинок та визначення активної зони.
За допомогою get_empty_cells/2 та get_active_zone/3 обчислюється множина клітинок, які потенційно є цікавими для ходу (тобто поруч із вже зайнятими клітинками).
Порівняння: У імперативних мовах це зазвичай робиться за допомогою вкладених циклів, а у функціональних — за допомогою операцій фільтрації. Тут застосовано логічні предикати, що дозволяють декларативно описати властивості активної зони.

2. Оцінка позицій
Оцінка напрямків.
Предикати evaluate_position/6 та evaluate_direction/8 визначають силу позиції шляхом підрахунку кількості послідовних фішок у кожному напрямку, із застосуванням арифметичної операції (10^кількість).
Оригінальний прийом: Рекурсивний підрахунок із використанням предиката next_count/10.

Критична загроза.
Предикат detect_critical_threat/4 перевіряє кожну порожню клітинку: якщо розміщення фішки призводить до перемоги, повертається ця позиція.
Перевага: Це дозволяє відразу реагувати на потенційні переможні ситуації, що є типовою технікою для ігор, де важливо блокувати суперника чи забезпечувати перемогу.

3. Вибір ходу (бот)
Бот має чотири рівні складності:

"very easy" – вибір випадкової клітинки з активної зони.

"easy" – спроба знайти критичну загрозу (для себе або супротивника), інакше – випадковий хід.

"medium" – 10% шанс на випадковий хід; якщо не випадає, спочатку перевіряється критична загроза, інакше – використовується простий алгоритм best_move (оцінка позиції: 2×своя оцінка + оцінка супротивника).

"hard" – 2% шанс на випадковий хід; якщо не випадає, перевіряється критична загроза, інакше – використовується алгоритм best_move_hard (комбінація оцінки патернів, що домінують у грі, помноженої на 100, плюс позиційна оцінка).

Порівняння з іншими методами:
У імперативному підході для подібних ігор часто використовується алгоритм мінімакс із альфа–бета відсіканням для пошуку оптимального ходу. Наш підхід є одноплановим (без повного глибокого пошуку), що робить його простішим, але менш потужним. Для більш сильного AI можна інтегрувати повноцінний мінімакс, що дозволяє вибирати хід, враховуючи кілька «півходів» вперед. Також можна застосувати метод CLP (програмування в обмеженнях), проте у цій задачі (для гри з досить обмеженим простором) його застосування було визнано надмірним через простоту проблеми.

Обґрунтування вибору евристики замість повноцінного мінімаксу
Для ігор із розміром ігрового поля більше 10×10 кількість можливих станів зростає експоненціально. Наприклад, при дошці 10×10 навіть якщо враховувати лише кілька ходів вперед, простір можливих позицій стає астрономічно великим. Використання стандартного алгоритму мінімаксу (навіть з альфа–бета відсіканням) в таких умовах може бути обчислювально неефективним або навіть практично неможливим через обмеження часу відповіді.

З цієї причини в нашому проєкті ми обрали комбінований евристичний підхід:

Евристична оцінка позиції.
Застосовується формула, що базується на підрахунку послідовних фішок: для "medium" рівня – це 2×своя оцінка плюс оцінка супротивника, що дозволяє швидко визначити перспективні ходи.

Використання патернів.
Для "hard" рівня застосовується комбінація патерн-детекції (де деякі конкретні шаблони, наприклад, "xxx.x", мають вагу) і позиційної оцінки. Цей підхід дозволяє виділити ходи, що мають високий потенціал для перемоги або блокування супротивника.

Обмеження області пошуку.
Завдяки визначенню "активної зони" (рядом із вже зайнятими клітинками) значно зменшується кількість потенційних ходів, що дозволяє обмежити пошук лише релевантними позиціями.

Переваги обраного підходу:

Ефективність.
Використання евристики дозволяє ботам приймати рішення за лічені мілісекунди навіть для великих дошок, що є критично важливим для інтерактивних додатків.

Гнучкість.
Евристичну оцінку можна легко налаштовувати, змінюючи ваги для різних патернів або комбінуючи її з іншими обмеженнями (наприклад, активною зоною). Це дозволяє адаптувати бота до різних рівнів складності та типів гри.

Масштабованість.
На відміну від повноцінного мінімаксу, який з ростом розміру дошки швидко стає непрактичним, евристика залишається обчислювально ефективною завдяки локалізації пошуку та простій обчислювальній складності окремих оцінок.

best_move/4
Мета:
Предикат використовується для рівня "medium". Він вибирає хід, що максимізує сумарну оцінку, де власна оцінка (оцінка позиції для поточного гравця) множиться на 2, а оцінка позиції для супротивника додається як додатковий коефіцієнт. Таким чином, надається перевага ходам, які не лише сприяють власному напередуванню, а й блокують можливості супротивника.

Логіка роботи:

Збір кандидатів:
За допомогою get_empty_cells/2 збираються усі порожні клітинки (позиції, де бот може зробити хід).

Оцінка кожного кандидата:
Для кожної порожньої клітинки (позиції) виконується:

Виклик evaluate_position/6 для поточного гравця (тобто, бот розраховує, наскільки сильна ця позиція для себе).

Виклик evaluate_position/6 для супротивника, щоб визначити, наскільки вигідним буде цей хід для суперника, якщо його не буде заблоковано.

Розраховується комбінована оцінка:
Score = 2 * SelfScore + OppScore.
Тут подвійна вага власної оцінки гарантує, що бот надає перевагу ходам, які сприяють його власній перемозі.

Вибір найкращого ходу:
Отриманий список кандидатів сортується за спаданням оцінки, і обирається кандидат із найбільшою оцінкою.

Приклад запиту:
?- best_move([[empty,x,empty],[empty,empty,empty],[empty,empty,empty]], x, 3, BestMove).
Може повернути, наприклад, BestMove = (0,2), що означає, що найкращий хід – поставити фішку у клітинку (0,2).

best_move_hard/4
Мета:
Цей предикат використовується для рівня "hard". Він поєднує два підходи:

Патерн-детекція: Аналізує, чи є у позиції певні важливі шаблони (наприклад, "xxx.x", "x.xxx"), які вказують на потенційно сильний хід. Оцінка цих патернів множиться на 100, що робить їх дуже вагомими.

Позиційна оцінка: Аналізує позицію з точки зору кількості послідовних фішок та ступеня блокування.

Логіка роботи:

Збір кандидатів:
Як і у попередньому випадку, отримуємо список усіх порожніх клітинок за допомогою get_empty_cells/2.

Оцінка кожного кандидата:
Для кожного потенційного ходу:

Викликається detect_patterns/7 для визначення патернових оцінок (наприклад, чи є конфігурація, яка дає можливість швидкої перемоги або блокування). Отриманий патерн-скор (PatternScore) помножується на 100.

Проводиться розрахунок позиційної оцінки через evaluate_position/6 (HeuristicScore).

Обчислюється загальна оцінка за формулою:
Score = PatternScore * 100 + HeuristicScore.
Таким чином, патернові показники мають більшу вагу, але позиційна оцінка також враховується.

Вибір найкращого ходу:
Список кандидатів сортується за спаданням отриманої оцінки, і обирається позиція з найвищою оцінкою.

Приклад запиту:
?- best_move_hard([[empty,x,empty],[empty,empty,empty],[empty,empty,empty]], x, 3, BestMove).
Може повернути, наприклад, BestMove = (0,2), що означає, що цей хід має найкращу комбінацію патернової оцінки та позиційної оцінки.



4. Додаткові алгоритмічні прийоми та власні рішення
Параметричні індикатори зв’язку.

Перетворення типів (Data conversion).
Використання допоміжного предиката fix_move/2 гарантує, що результат ходу, який повертається у вигляді терму (наприклад, ,(R,C)), перетворюється у список [R,C] для зручності обробки в Python.
Порівняння: У імперативних мовах подібне перетворення здійснюється через ручне приведення типів, а у функціональних мовах — через патерн-матчинг.

Оригінальні прийоми логічного програмування:
Використання декларативних предикатів для опису множинних аспектів предметної області (стан гри, оцінка позиції, пошук критичних загроз) дозволяє легко модифікувати логіку гри та комбінувати різні методи (наприклад, патерн-детекцію з оцінкою позиції).
Крім того, застосування cut (зеленого) у check_winner/4 та інших предикатах дозволяє оптимізувати пошук, що є типовою технікою в Пролозі.


Манхеттенська відстань:
У нашій логіці використовується поняття «активної зони», яке фактично є аналогом обмеження за манхеттенською відстанню. В імперативних рішеннях зазвичай розраховують манхеттенську відстань безпосередньо, а у функціональних — застосовують фільтрацію. У нашому випадку ми логічно описали вимогу, що клітинки повинні бути поруч із заповненими, що знижує розгалуженість пошуку.

Складнощі та шляхи їх подолання
Обмін даними між Python та Prolog.
Найбільша складність виникла через необхідність перетворення типів даних (наприклад, формат представлення ходів). Використання допоміжного предиката fix_move/2 вирішило цю проблему.

Визначення активної зони.
Декларативне визначення активної зони (порівняно з циклічними переборами у імперативних мовах) спрощує код, хоча може бути менш ефективним для дуже великих полів.

Налаштування алгоритмів оцінки.
Підбір коефіцієнтів для патернів та оцінка позицій вимагали експериментів для досягнення задовільної гри бота. Це було частково вирішено за допомогою порівняння з імперативними реалізаціями, де подібні значення використовуються.
